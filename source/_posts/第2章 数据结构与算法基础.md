---
title: 第2章 数据结构与算法基础
date: 2024-10-03 00:00:00
categories: 软件设计师
tag: 
	- 数据结构
---


<!-- toc -->

# 1. 基础概念

- **数据**：数据是信息的载体，是描述客观事物属性的数值、字符及所有能输入到计算机中并被计算机程序识别和处理的符号集合。数据是计算机程序加工和处理的原料。
- **数据元素**：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
- **数据项**：一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。
- **数据结构**：相互之间存在一种或多种特定关系的数据元素的集合。
	- **逻辑结构**：集合结构、线性结构、树状结构、网状结构。
	- **物理结构**：顺序存储、链式存储、索引存储、散列存储。
	- **数学运算**

# 2. 算法

算法的五个特性：
- **有穷性**：一个算法必须在执行有限步之后结束，并且每一步都能在有限时间内完成。
- **确定性**：算法中每条指令必须具有确切的含义，对于相同的输入只能得出相同的输出结果。
- **可行性**：算法中描述的操作都可以通过已经实现的基本运算，在有限次操作内完成。
- **输入**：一个算法可以有零个或多个输入，这些输入取自某个特定对象的集合。
- **输出**：一个算法必须有一个或多个输出，这些输出是与输入具有某种特定关系的量。

 算法效率的度量：
 - **时间复杂度**
 - **空间复杂度**

# 3. 线性表

## 3.1 定义

线性表是由 $n$（$n \geq 0$）个具有相同数据类型的元素组成的有限序列，其中 $n$ 为表长。当 $n = 0$ 时，线性表为空表。

用 $L$ 表示线性表时，通常表示为：

$$ L = (a_1, a_2, \ldots, a_i, a_{i+1}, \ldots, a_n) $$

- **第 $i$ 个元素**：表示线性表中的第 $i$ 个数据元素。
- **表头元素**：第一个元素 $a_1$。
- **表尾元素**：最后一个元素 $a_n$。
- 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。

## 3.2 存储结构

- 顺序存储——线性表
- 链式存储——链表
	- 双向链表
	- 循环链表
	- 静态链表

| 性能类别     | 具体项目       | 顺序存储                     | 链式存储                                    |
|--------------|----------------|-----------------------------|---------------------------------------------|
| **空间性能** | 存储密度       | =1，更优                    | < 1                                         |
|              | 容量分配       | 事先确定                    | 动态改变，更优                              |
| **时间性能** | 查找运算       | $O(n/2)$                    | $O((n+1)/2)$，最好情况为1，最坏情况为$n$   |
|              | 读运算         | $O(1)$，更优                | $O(1)$，更优                                |
|              | 插入运算       | $O(n/2)$，最好情况为0，最坏情况为$n$ | $O(1)$，更优                                |
|              | 删除运算       | $O((n-1)/2)$                | $O(1)$，更优                                |

## 3.3 插入删除操作

**顺序存储**：在插入元素前需要移动后续元素以腾出空的存储单元，然后再插入元素；删除元素时同样需要移动后续元素以填补被删除元素的存储单元位置。

**链式存储**：在插入或删除元素时不需要移动其他元素，只需修改相关节点的指针即可，操作效率较高。链式存储能够动态分配存储空间，适合频繁的插入和删除操作。

## 3.4 栈和队列


线性表是由 $n$（$n \geq 0$）个具有相同数据类型的元素组成的有限序列，其中 $n$ 为表长。当 $n = 0$ 时，线性表为空表。若用 $L$ 表示线性表，则其一般表示为：

$$ L = (a_1, a_2, \ldots, a_i, a_{i+1}, \ldots, a_n) $$

**栈 (Stack)** 是一种特殊的线性表，它只允许在一端（称为栈顶）进行插入或删除操作。这种操作方式被称为 “后进先出 (LIFO)” 原则，即最后插入的元素最先被删除。

队列（Queue）是一种**先进先出（FIFO）** 的线性表。它只允许在表的一端插入元素，而在表的另一端删除元素。  **队尾（Rear）** 是允许插入元素的一端。 **队头（Front）** 是允许删除元素的一端。

## 3.5 串、数组、矩阵和广义表

## 3.5.1 串

串（String）是仅由字符构成的有限序列，是取值范围受限的线性表。通常表示为 $S = a_1 a_2 \ldots a_n$，其中 $S$ 是串名，$a_1, a_2, \ldots, a_n$ 是串值。

**串的基本概念**：
1. **空串**：长度为零的串，不包含任何字符。
2. **空格串**：由一个或多个空格组成的串。
3. **子串**：由主串中任意长度的连续字符构成的序列。空串是任意串的子串。
4. **串相等**：两个串长度相等且对应位置上的字符相同。
5. **串比较**：比较时以字符的 ASCII 码值为依据，从第一个字符开始依次比较。若某个串先结束，则串长较大者为大。

**对串的基本操作**：
   1. **赋值操作** `StrAssign(s, t)`：将串 `t` 的值赋给串 `s`。
   2. **连接操作** `Concat(s, t)`：将串 `t` 接续在串 `s` 的尾部，形成一个新串。
   3. **求串长** `StrLength(s)`：返回串 `s` 的长度。
   4. **串比较** `StrCompare(s, t)`：比较两个串的大小。
   5. **求子串** `SubString(s, start, len)`：返回串 `s` 中从 `start` 开始、长度为 `len` 的字符序列。

**串的存储结构**：
   1. **顺序存储**：采用定长存储结构。
   2. **链式存储**：采用块链结构。

**子串定位操作（模式匹配）**：用于查找子串在主串中的位置，子串也称为模式串，是串处理系统中最重要的操作之一。

### 3.5.2 数组

| 数组类型 | 存储地址计算                                                   |
|----------|----------------------------------------------------------------|
| **一维数组**  | $a[i]$ 的存储地址为：$a + i \times \text{len}$                                 |
| **二维数组**  | $a[i][j]$ 的存储地址（按行存储）为：$a + (i \times n + j) \times \text{len}$   |
|          | $a[i][j]$ 的存储地址（按列存储）为：$a + (j \times m + i) \times \text{len}$        |

### 3.5.3 稀疏矩阵

| 稀疏矩阵类型    | 要点                                                                |
| --------- | ----------------------------------------------------------------- |
| **上三角矩阵** | 在矩阵中下标分别为 $i$ 和 $j$ 的元素，对应的一维数组的下标计算公式为：$(2n-i+1) \times i/2 + j$ |
| **下三角矩阵** | 在矩阵中下标分别为 $i$ 和 $j$ 的元素，对应的一维数组的下标计算公式为：$(i+1) \times i/2 + j$    |

### 3.5.4 广义表

- **广义表**是由 $n$ 个表元素组成的有限序列，是线性表的推广。通常使用递归的形式定义，表示为：  
  $$ LS = (a_0, a_1, \ldots, a_n) $$

- **注意**：
  - $LS$ 是表名，$a$ 是表元素，可以是表（称为子表）或数据元素（称为原子）。
  - $n$ 是广义表的长度，即最外层包含的元素个数。  
  - 递归定义的重数称为广义表的**深度**。

- **基本操作**：
  - **取表头** `head(LS)`：返回广义表的第一个元素。
  - **取表尾** `tail(LS)`：返回广义表中除去表头后的剩余部分。

例如：  
若有 $LS1 = (a, (b, c), (d, e))$，则：
- `head(LS1) = a`  
- `tail(LS1) = ((b, c), (d, e))`

# 4. 树

## 4.1 基本概念

1. **结点的度**：结点所拥有的子结点的个数称为该结点的度。
2. **树的度**：树中所有结点的度的最大值称为树的度。
3. **叶子结点**：度为零的结点，即没有子结点的结点。
4. **分支结点/内部结点**：度不为零的结点，即有子结点的结点。
5. **父结点**：某个结点的直接上级结点。
6. **子结点**：某个结点的直接下级结点。
7. **兄弟结点**：具有同一个父结点的结点。
8. **层次**：从根结点开始，根为第 1 层，根的子结点为第 2 层，以此类推。

## 4.2 二叉树的基本概念


1. **第 $i$ 层的结点数**：在二叉树的第 $i$ 层上最多有 $2^{i-1}$ 个结点（$i \geq 1$）。
2. **深度为 $k$ 的二叉树的结点总数**：深度为 $k$ 的二叉树最多有 $2^k - 1$ 个结点（$k \geq 1$）。
3. **叶子结点数与度为 2 的结点数关系**：对于任意一棵二叉树，如果叶子结点数为 $n_0$，度为 2 的结点数为 $n_2$，则满足关系：  
   $$ n_0 = n_2 + 1 $$
4. **完全二叉树的性质**：对于一棵有 $n$ 个结点的完全二叉树，如果结点按层序编号（从第 1 层到 $\lfloor \log_2 n \rfloor + 1$ 层，每层从左到右），则：
   - 若 $i = 1$，结点 $i$ 是二叉树的根结点。
   - 若 $i > 1$，结点 $i$ 的父结点为结点 $\lfloor i/2 \rfloor$。
   - 若 $2i \leq n$，结点 $i$ 的左子结点为结点 $2i$；否则，结点 $i$ 为叶子结点，无左子结点。
   - 若 $2i+1 \leq n$，结点 $i$ 的右子结点为结点 $2i + 1$；否则，结点 $i$ 无右子结点。

## 4.3 二叉树的遍历

1. **前序遍历**（Pre-order Traversal）：先访问根结点，然后访问左子树，最后访问右子树。  
2. **后序遍历**（Post-order Traversal）：先访问左子树，然后访问右子树，最后访问根结点。  
3. **中序遍历**（In-order Traversal）：先访问左子树，然后访问根结点，最后访问右子树。  
4. **层次遍历**（Level-order Traversal）：按照树的层次，从上到下，从左到右依次访问每一层的结点。

## 4.4 二叉搜索树

**特性**：  
- **左子结点**的值小于根结点。
- **右子结点**的值大于根结点。

**插入结点**：
1. 若该结点已存在，则不再插入。
2. 若查找为空树，则新结点为根结点。
3. 插入时，比较新结点与父结点的值，确定插入左子结点或右子结点。

**删除结点**：
1. 若结点为叶子结点，直接删除。
2. 若结点有一个子结点，用其子结点替代自己。
3. 若结点有两个子结点，找到左子树中值最大的结点，用其值替代该结点，再删除该结点。

### 4.5 霍夫曼树 (Huffman Tree)

- 霍夫曼树是一种最优二叉树，用于解决数据压缩问题。通过使用出现频率较高的字符构造较短的编码，可以有效减少编码后的数据长度。
- 霍夫曼树的构建步骤：
	1. 将所有待编码的字符按照其频率（权值）升序排列，每个字符作为一个独立的结点。
	2. 从中选择两个具有最小权值的结点作为左右子结点，构造新结点，其权值为两个子结点的权值之和。
	3. 将新结点插入队列中，并重复以上步骤，直到队列中只剩一个结点为止。

### 4.6 线索二叉树 (Threaded Binary Tree)

- 线索二叉树是一种改进的二叉树结构，在二叉树的每个结点中加入指向前驱和后继结点的指针（称为线索），以便在遍历时无需栈或递归，提高遍历效率。
- 线索分类：
  1. **前序线索二叉树**：线索指向结点的前序前驱和前序后继。
  2. **中序线索二叉树**：线索指向结点的中序前驱和中序后继。
  3. **后序线索二叉树**：线索指向结点的后序前驱和后序后继。

### 4.7 平衡二叉树 (Balanced Binary Tree)

- 平衡二叉树是一种特殊的二叉搜索树，它保证树的左右子树高度差不超过 1，以保持树的平衡，从而保证搜索、插入和删除操作的时间复杂度为 $O(\log n)$。
- 常见的平衡二叉树有：
  1. **AVL 树**：通过旋转操作来维持树的平衡，每个结点维护一个平衡因子，表示左子树和右子树的高度差。
  2. **红黑树**：通过颜色标记和旋转操作来保持树的平衡，插入和删除的调整次数少于 AVL 树，广泛应用于 STL 的 `map` 和 `set` 容器中。

# 5. 图

## 5.1 基本概念

1. **有向图**：图中所有边都有方向，即每条边用箭头表示，表示从某个顶点指向另一个顶点。
2. **无向图**：图中所有边没有方向，即每条边只连接两个顶点，不区分方向性。
3. **完全图**：
   - **无向完全图**：若无向图中任意两个顶点之间都有一条边相连，则称为完全图。
   - **有向完全图**：若有向图中任意两个顶点之间都有两条相互对称的有向边，则称为完全图。
4. **度、入度与出度**：
   - **度**：一个顶点的度是指与该顶点相连的边数。
   - **入度**：有向图中指向该顶点的边的数量。
   - **出度**：有向图中从该顶点发出的边的数量。

## 5.2 存储结构

1. **邻接矩阵（Adjacency Matrix）**：
   - 邻接矩阵是一种二维数组表示法，用于表示图中顶点和边的关系。
   - 在无向图中，若顶点 $v_i$ 与 $v_j$ 之间存在边，则对应的矩阵元素 $a_{ij} = 1$；否则，$a_{ij} = 0$。
   - 在有向图中，若顶点 $v_i$ 指向顶点 $v_j$，则 $a_{ij} = 1$；否则，$a_{ij} = 0$。
   - 优点：易于理解和操作，适合密集图（边多）使用。
   - 缺点：当图中顶点较多、边较少时，空间浪费严重。
2. **邻接表（Adjacency List）**：
   - 邻接表使用链表结构来表示图中顶点和边的关系。每个顶点对应一个链表，链表中存储与该顶点直接相连的顶点。
   - 邻接表比邻接矩阵更节省空间，适合稀疏图（边少）使用。
   - 优点：节省空间，适合表示边数远小于顶点数的图。
   - 缺点：查找顶点之间是否有边相连的效率不如邻接矩阵。

## 5.3 图的遍历

1. **深度优先遍历（DFS, Depth-First Search）**：
	 1. 首先访问出发顶点 $V$。
	 2. 从 $V$ 出发，依次搜索 $V$ 的任意一个未访问的邻接点 $W$。
	 3. 如果 $W$ 未访问过，则从 $W$ 出发继续进行深度优先遍历，直到所有顶点都被访问完毕。
2. **广度优先遍历（BFS, Breadth-First Search）**：
	 1. 首先访问出发顶点 $V$。
	 2. 访问与 $V$ 邻接的所有未访问顶点（例如：$W, X, Y, \ldots$）。
	 3. 然后依次从 $W, X, Y, \ldots$ 出发访问其未访问的邻接顶点，直到所有顶点都被访问完毕。

## 5.4 拓扑排序

**拓扑排序（Topological Sorting）** 是一种用于 **AOV 网络**（Activity on Vertex Network）中的排序方法，用来确定有向无环图（DAG）中顶点的线性序列。

- **AOV 网络**：是以顶点表示活动、以有向边表示活动间优先关系的有向图。AOV 网络中不存在环，即不包含任何循环路径。
- **拓扑排序的应用**：
  - 拓扑排序主要用于表示具有依赖关系的任务序列，广泛用于项目调度、编译器符号依赖分析等场景。
- **算法思想**：
  1. 从 AOV 网络中选择一个入度为 0 的顶点并将其输出（访问）。
  2. 从图中删除该顶点及所有与其相关联的边。
  3. 重复以上步骤，直到所有顶点都被访问完毕或者图中不存在入度为 0 的顶点为止。若在遍历中图中存在入度不为 0 的顶点，则说明图中存在环。

**拓扑排序的结果**是一个线性序列，表示各个活动之间的依赖顺序，使得所有前驱活动在每个后继活动之前完成。

## 5.5 最小生成树

最小生成树（Minimum Spanning Tree, MST）是在一个带权连通无向图中，选取若干边，使得所有顶点连通且选取的边权值之和最小的树。

- **Kruskal 算法**：
  - 基于边的贪心算法。首先将所有边按权值从小到大排序，然后依次选择权值最小且不会形成环的边，直至选取了 $n-1$ 条边（$n$ 为顶点数）。
  - **时间复杂度**：$O(E \log E)$ 或 $O(E \log V)$（$E$ 为边数，$V$ 为顶点数）

- **Prim 算法**：
  - 基于顶点的贪心算法。从任意顶点出发，每次选择与当前生成树最小权值的边，并将该边的另一个顶点加入生成树中，直至所有顶点都被加入生成树。
  - **时间复杂度**： $O(V^2)$ 或 $O(E \log V)$（$E$ 为边数，$V$ 为顶点数）

## 5.6 最短路径

- **Floyd 算法**：
  - 适用于任意两点之间的最短路径，基于动态规划，时间复杂度为 $O(n^3)$。遍历图中的所有顶点，通过每个顶点更新任意两点之间的最短路径。

- **Dijkstra 算法**：
  - 适用于单源最短路径（从一个顶点到其他所有顶点的最短路径），每次从未访问的顶点中选择最短路径的顶点，并更新其他顶点的最短路径。时间复杂度为 $O(n^2)$（适用于稠密图）或 $O(E \log n)$（使用优先队列，适用于稀疏图）。

## 6. 查找

## 6.1 基本概念

1. **查找**：在数据集合中寻找满足某种条件的数据元素的过程。
2. **查找表（查找结构）**：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。
3. **关键字**：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，结果应当是唯一的。
4. **查找长度**：查找过程中，需要对比关键字的次数称为查找长度。
5. **平均查找长度（ASL, Average Search Length）**：所有查找过程中进行关键字比较次数的平均值。

## 6.2 顺序查找（Linear Search）

**思想**：从数据集合的第一个元素开始，逐个比较，直到找到目标元素或遍历完整个集合。  
**时间复杂度**：$O(n)$  
**适用场景**：数据量较小，或者数据未排序的集合。

## 6.3 二分查找（Binary Search）

**思想**：要求数据集合已排序，每次将查找范围缩小一半。比较中间元素与目标元素的大小，确定下一步查找方向，直到找到目标或查找范围为空。  
**时间复杂度**：$O(\log n)$  
**适用场景**：数据量较大且已排序的集合。

## 6.4 哈希表（Hash Table）

**思想**：利用哈希函数将关键字映射到哈希表中的位置进行存储和查找。查找效率高，可达到 $O(1)$。  
**时间复杂度**：平均 $O(1)$，最坏情况 $O(n)$  
**适用场景**：查找速度要求极高的场景，如数据库索引、缓存。

# 7. 排序

## 7.1 基本概念

1. **排序**：是指将序列中的元素重新排列，使其满足按关键字有序的过程。
2. **排序的分类**：
   - **按稳定性分类**：稳定排序和不稳定排序。
   - **按操作方式分类**：内部排序和外部排序。
3. **排序方法分类**：
   - **插入类排序**：直接插入排序、希尔排序
   - **交换类排序**：冒泡排序、快速排序
   - **选择类排序**：简单选择排序、堆排序
   - **其他排序**：归并排序、基数排序

## 7.2 直接插入排序（Insertion Sort）

**思想**：每次将一个元素插入到已排序序列的合适位置，直到所有元素插入完毕。  
**时间复杂度**：$O(n^2)$  
**空间复杂度**：$O(1)$  
**稳定性**：稳定  
**适用场景**：数据量小或部分有序的情况。

## 7.3 希尔排序（Shell Sort）

**思想**：基于插入排序的改进，通过将序列按一定增量分组，对每组进行插入排序，逐步缩小增量，最终对整体排序。  
**时间复杂度**：$O(n^{3/2})$ 到 $O(n^2)$，取决于增量序列  
**空间复杂度**：$O(1)$  
**稳定性**：不稳定  
**适用场景**：数据量较大的无序序列。

## 7.4 冒泡排序（Bubble Sort）

**思想**：重复地遍历序列，每次比较相邻元素并交换位置，使较大元素逐渐“冒泡”到序列末尾。  
**时间复杂度**：$O(n^2)$  
**空间复杂度**：$O(1)$  
**稳定性**：稳定  
**适用场景**：数据量小且初始状态接近有序的情况。

## 7.5 快速排序（Quick Sort）

**思想**：选择一个基准元素，将序列分为比基准小和比基准大的两个子序列，递归地对两个子序列排序。  
**时间复杂度**：平均 $O(n \log n)$，最坏情况 $O(n^2)$  
**空间复杂度**：$O(\log n)$（递归调用栈）  
**稳定性**：不稳定  
**适用场景**：通用排序算法，适用于大部分情况。

## 7.6 简单选择排序（Selection Sort）

**思想**：每次从未排序序列中选出最小或最大的元素，放到已排序序列的末尾，直到所有元素排序完毕。  
**时间复杂度**：$O(n^2)$  
**空间复杂度**：$O(1)$  
**稳定性**：不稳定  
**适用场景**：数据量小的序列。

## 7.7 堆排序（Heap Sort）

**思想**：将序列构建成最大堆或最小堆，每次取出堆顶元素（最大或最小），调整堆，直至所有元素排序完毕。  
**时间复杂度**：$O(n \log n)$  
**空间复杂度**：$O(1)$  
**稳定性**：不稳定  
**适用场景**：需要使用较少额外空间的场景。

## 7.8 归并排序（Merge Sort）

**思想**：将序列递归地分为两部分，分别排序后合并。  
**时间复杂度**：$O(n \log n)$  
**空间复杂度**：$O(n)$  
**稳定性**：稳定  
**适用场景**：适用于大规模数据的外部排序（文件排序）。

## 7.9 基数排序（Radix Sort）

**思想**：按照各个数位（个位、十位等）依次对数据进行分配和收集，直到所有位排序完毕。  
**时间复杂度**：$O(d \times (n + k))$（$d$ 为位数，$k$ 为每位的取值范围）  
**空间复杂度**：$O(n + k)$  
**稳定性**：稳定  
**适用场景**：适合数值型数据的排序。

## 7.10 评价指标

| 类别      | 排序方法       | 时间复杂度（平均情况） | 时间复杂度（最坏情况） | 空间复杂度 | 稳定性   |
|-----------|----------------|-----------------------|-----------------------|------------|----------|
| 插入排序  | 直接插入排序   | $O(n^2)$              | $O(n^2)$              | $O(1)$     | 稳定     |
| 插入排序  | 希尔排序       | $O(n^{1.3})$          | $O(n^2)$              | $O(1)$     | 不稳定   |
| 选择排序  | 直接选择排序   | $O(n^2)$              | $O(n^2)$              | $O(1)$     | 不稳定   |
| 选择排序  | 堆排序         | $O(n \log n)$         | $O(n \log n)$         | $O(1)$     | 不稳定   |
| 交换排序  | 冒泡排序       | $O(n^2)$              | $O(n^2)$              | $O(1)$     | 稳定     |
| 交换排序  | 快速排序       | $O(n \log n)$         | $O(n^2)$              | $O(\log n)$| 不稳定   |
| 归并排序  | 归并排序       | $O(n \log n)$         | $O(n \log n)$         | $O(n)$     | 稳定     |
| 归并排序  | 基数排序       | $O(d(r+n))$           | $O(d(r+n))$           | $O(r+n)$   | 稳定     |

- **稳定性**：在排序过程中，如果两个相等的元素排序前后的相对位置不发生变化，则称该排序算法是稳定的。
- **时间复杂度**：描述算法执行时间随数据规模变化的增长情况。
- **空间复杂度**：描述算法在执行过程中所需的额外空间大小。


