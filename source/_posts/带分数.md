---
title: 洛谷P8599 带分数
date: 2024-07-28 22:45:00
categories: Coding日记
tag:
    - DFS
    - 模拟
---

<!-- toc -->

## 题目描述

$100$ 可以表示为带分数的形式：$100 = 3 + \frac{69258}{714}$。

还可以表示为：$100 = 82 + \frac{3546}{197}$。

注意特征：带分数中，数字 $1$ ~ $9$ 分别出现且只出现一次（不包含 $0$）。

类似这样的带分数，$100$ 有 $11$ 种表示法。

## 输入格式

从标准输入读入一个正整数 $N(N<10^6)$。

## 输出格式

程序输出数字 $N$ 用数码 $1$ ~ $9$ 不重复不遗漏地组成带分数表示的全部种数。

注意：不要求输出每个表示，只统计有多少表示法！

## 样例 #1

### 样例输入 #1

```
100
```

### 样例输出 #1

```
11
```

## 样例 #2

### 样例输入 #2

```
105
```

### 样例输出 #2

```
6
```

## 提示

原题时限 3 秒, 64M。蓝桥杯 2013 年第四届省赛

## 求解思路 1
本题题意很简单，即求满足以下两个条件的方案数：
1. $a$,$b$,$c$的每一位数分别是1~9，且不允许重复
2. $n=a+\frac{b}{c}$

本题的数据量相对较小，因而可以直接对a,b,c进行枚举，暴力求解。具体步骤如下：
1. 从0~n-1枚举a的值，并对a使用的数字进行标记
2. 在目前可用的数字中枚举b的所有可能
3. 根据简单的数学变换，直接计算c的值并且验证是否满足上述条件

## 代码实现 1

具体的代码实现采用了dfs递归求解。

``` cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n; // 目标数字
long long a, b, c; // a、b、c 分别表示不同的数字
long long b_divideBy_c; // b 除以 c 的结果
int st[10]; // 用于记录数字是否已经使用
int cnt = 9; // 剩余可用的数字个数
int ans; // 满足条件的方案数

// 深度优先搜索函数，用于生成可能的 b 并进行验证
void dfs(int u) 
{
    if (u >= cnt) 
    {
        return; // 递归结束条件：已用完所有可用数字
    }

    // 验证 b 是否可以被 b_divideBy_c 整除且 b 不为零
    if (b % b_divideBy_c == 0 && b != 0) 
    {
        c = b / b_divideBy_c; // 计算 c
        int test = c; // 临时变量用于验证 c 的每一位
        int backup[10]; // 备份数组 st
        std::copy(st, st + 10, backup); // 复制 st 到 backup
        bool valid = true; // 用于标记 c 是否有效
        while (test) {
            int temp = test % 10; // 取 c 的最后一位
            test /= 10; // 去掉 c 的最后一位
            if (!temp || backup[temp]) 
            {
                valid = false; // 如果 c 包含 0 或重复数字，则无效
                break;
            }
            backup[temp] = 1; // 记录该数字已使用
        }
        if (valid) 
        {
            for (int i = 1; i < 10; ++i) 
            {
                if (backup[i] == 0) 
                {
                    valid = false; // 如果有数字未使用，则无效
                    break;
                }
            }
        }
        if (valid) 
        {
            ++ans; // 如果 c 有效，则计数加一
        }
    }

    // 尝试在 b 中添加新的数字
    for (int i = 1; i < 10; i++)
    {
        if (!st[i])
        {
            st[i] = 1; // 标记数字 i 已使用
            b = b * 10 + i; // 将 i 添加到 b 的末尾
            dfs(u + 1); // 递归调用 dfs
            st[i] = 0; // 回溯，标记数字 i 未使用
            b = (b - i) / 10; // 从 b 的末尾移除 i
        }
    }
}

int main() 
{
    cin >> n; // 读取输入 n
    for (int i = 1; i < n; i++)
    {
        fill(st, st + 10, 0); // 初始化 st 数组
        cnt = 9; // 重置剩余可用数字个数
        a = i; // 当前数字 a
        bool valid = true; // 用于标记 a 是否有效

        // 验证 a 并更新 st
        long long temp_a = a;
        while (temp_a)
        {
            int digit = temp_a % 10; // 取 a 的最后一位
            if (digit == 0 || st[digit])
            {
                valid = false; // 如果 a 包含 0 或重复数字，则无效
                break;
            }
            st[digit] = 1; // 记录该数字已使用
            --cnt; // 剩余可用数字个数减一
            temp_a /= 10; // 去掉 a 的最后一位
        }

        if (!valid) 
        {
            continue; // 如果 a 无效，则跳过当前循环
        }

        b = 0; // 初始化 b
        c = 0; // 初始化 c
        b_divideBy_c = n - a; // 计算 b_divideBy_c
        dfs(0); // 调用 dfs 函数
    }
    cout << ans << endl; // 输出满足条件的方案数
}
```

## 求解思路 2

以上方法在本题可以顺利AC，不过在查阅资料时我看到了一种更好的求解思路。利用C++ STL中的[next_permutation](https://blog.csdn.net/qq_47997583/article/details/115802189)函数对数字1~9进行全排列，而后只需要对得到的排列枚举两个断点即可得到a,b,c的值，最后只需要判断是否满足约束条件，若满足则方案数加一，反之则继续枚举判断。

``` cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n; // 目标数字
int a, b, c; // a、b、c 分别表示不同的数字
int num[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; // 用于生成排列的数字数组
int ans; // 满足条件的方案数

int main() 
{
    cin >> n; // 读取输入 n

    // 生成 num 数组的所有排列
    do 
    {
        // 通过选择 i 和 j 分割 num 数组生成 a, b, c
        for (int i = 0; i < 7; ++i) 
        {
            for (int j = i + 1; j < 8; ++j) 
            {
                a = 0, b = 0, c = 0; // 初始化 a, b, c

                // 生成 a：由 num 的前 i+1 个数字组成
                for (int t = 0; t <= i; ++t) 
                {
                    a *= 10;
                    a += num[t];
                }

                // 如果 a 大于或等于 n，则跳过该组合
                if (a >= n)
                    continue;

                // 生成 b：由 num 的从 i+1 到 j 的数字组成
                for (int t = i + 1; t <= j; ++t) 
                {
                    b *= 10;
                    b += num[t];
                }

                // 生成 c：由 num 的从 j+1 到 8 的数字组成
                for (int t = j + 1; t < 9; ++t) 
                {
                    c *= 10;
                    c += num[t];
                }

                // 如果 b 不能被 c 整除，则跳过该组合
                if (b % c)
                    continue;

                // 如果 n 等于 a + b / c，则计数加一
                if (n == a + b / c)
                    ans++;
            }
        }
    } while (next_permutation(num, num + 9)); // 生成 num 的下一个排列

    cout << ans; // 输出满足条件的方案数
}
```

## 题目总结

这道题最早接触的时候还在23年大一上的寒假，当时连C++的基础语法都没有掌握，连acwing的讲解视频都不怎么看得懂，以为这题很难很难。转眼一年半过去了，现在重新回头来看，其实只是一个模拟题而已，只需要按照约束条件一步一步来就能够得到答案，算法设计和时间复杂度方面的要求都并不高。而今从这道题目开始重新练习算法题，也算是对过去的自己的一个回应，希望能够继续前行。